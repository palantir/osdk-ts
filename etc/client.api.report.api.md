## API Report File for "@osdk/client.api"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { BBox } from 'geojson';
import type { BrandedApiName } from '@osdk/api';
import type { InterfaceDefinition } from '@osdk/api';
import type { ObjectOrInterfaceDefinition } from '@osdk/api';
import type { ObjectOrInterfacePropertyKeysFrom2 } from '@osdk/api';
import type { ObjectQueryDataType } from '@osdk/api';
import type { ObjectSetQueryDataType } from '@osdk/api';
import type { ObjectTypeDefinition } from '@osdk/api';
import type { ObjectTypeLinkDefinition } from '@osdk/api';
import type { ObjectTypeLinkKeysFrom2 } from '@osdk/api';
import type { ObjectTypePropertyDefinition } from '@osdk/api';
import type { Point } from 'geojson';
import type { Polygon } from 'geojson';
import type { QueryDataTypeDefinition } from '@osdk/api';
import type { QueryDefinition } from '@osdk/api';
import type { SingleKeyObject } from 'type-fest';

// Warning: (ae-forgotten-export) The symbol "ActionResults" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type ActionEditResponse = ActionResults;

// @public
export namespace ActionParam {
    export type ObjectSetType<T extends ObjectTypeDefinition<any>> = BaseObjectSet<T>;
    export type ObjectType<T extends ObjectTypeDefinition<any>> = OsdkBase<T> | OsdkObjectPrimaryKeyType<T>;
    export type PrimitiveType<T extends keyof DataValueClientToWire> = DataValueClientToWire[T];
}

// @public (undocumented)
export type ActionReturnTypeForOptions<Op extends ApplyActionOptions | ApplyBatchActionOptions> = Op extends {
    $validateOnly: true;
} ? ActionValidationResponse : Op extends {
    $returnEdits: true;
} ? ActionEditResponse : undefined;

// Warning: (ae-forgotten-export) The symbol "ValidateActionResponseV2" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type ActionValidationResponse = ValidateActionResponseV2;

// @public (undocumented)
export type AggregatableKeys<Q extends ObjectOrInterfaceDefinition> = keyof {
    [P in keyof Q["properties"]]: any;
};

// @public (undocumented)
export type AggregateOpts<Q extends ObjectOrInterfaceDefinition> = {
    $select: UnorderedAggregationClause<Q> | OrderedAggregationClause<Q>;
    $where?: WhereClause<Q>;
    $groupBy?: GroupByClause<Q>;
};

// Warning: (ae-forgotten-export) The symbol "AggregateOptsThatErrors" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type AggregateOptsThatErrorsAndDisallowsOrderingWithMultipleGroupBy<Q extends ObjectOrInterfaceDefinition, AO extends AggregateOpts<Q>> = SingleKeyObject<AO["$groupBy"]> extends never ? (AO["$select"] extends UnorderedAggregationClause<Q> ? AggregateOptsThatErrors<Q, AO> : {} extends AO["$groupBy"] ? AggregateOptsThatErrors<Q, AO> : {
    $groupBy: AO["$groupBy"];
    $select: UnorderedAggregationClause<Q>;
    $where?: AO["$where"];
}) : AggregateOptsThatErrors<Q, AO>;

// @public (undocumented)
export type AggregationResultsWithGroups<Q extends ObjectOrInterfaceDefinition<any, any>, A extends UnorderedAggregationClause<Q> | OrderedAggregationClause<Q>, G extends GroupByClause<Q> | undefined> = ({
    $group: {
        [P in keyof G & keyof Q["properties"]]: G[P] extends {
            $ranges: GroupByRange<infer T>[];
        } ? {
            startValue: T;
            endValue: T;
        } : OsdkObjectPropertyType<Q["properties"][P], true>;
    };
} & AggregationResultsWithoutGroups<Q, A>)[];

// Warning: (ae-forgotten-export) The symbol "ExtractPropName" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ExtractMetricNameForPropName" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type AggregationResultsWithoutGroups<Q extends ObjectOrInterfaceDefinition<any, any>, AC extends UnorderedAggregationClause<Q> | OrderedAggregationClause<Q>> = {
    [PropName in ExtractPropName<keyof AC & string>]: PropName extends "$count" ? number : {
        [MetricName in ExtractMetricNameForPropName<keyof AC & string, PropName>]: MetricName extends "approximateDistinct" ? number : OsdkObjectPropertyType<Q["properties"][PropName]>;
    };
};

// @public (undocumented)
export type AggregationsResults<Q extends ObjectOrInterfaceDefinition, AO extends AggregateOpts<Q>> = Exclude<keyof AO["$select"], ValidAggregationKeys<Q>> extends never ? unknown extends AO["$groupBy"] ? AggregationResultsWithoutGroups<Q, AO["$select"]> : Exclude<AO["$groupBy"], undefined> extends never ? AggregationResultsWithoutGroups<Q, AO["$select"]> : Exclude<keyof AO["$groupBy"], AggregatableKeys<Q>> extends never ? AggregationResultsWithGroups<Q, AO["$select"], AO["$groupBy"]> : `Sorry, the following are not valid groups for an aggregation: ${Exclude<keyof AO["$groupBy"] & string, AggregatableKeys<Q>>}` : `Sorry, the following are not valid selectors for an aggregation: ${Exclude<keyof AO["$select"] & string, ValidAggregationKeys<Q>>}`;

// Warning: (ae-forgotten-export) The symbol "GroupByMapper" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type AllGroupByValues = GroupByMapper[keyof GroupByMapper];

// @public (undocumented)
export type AllowedBucketKeyTypes = AllowedBucketTypes | {
    startValue: AllowedBucketTypes;
    endValue: AllowedBucketTypes;
};

// @public (undocumented)
export type AllowedBucketTypes = string | number | boolean;

// @public (undocumented)
export interface AndWhereClause<T extends ObjectOrInterfaceDefinition<any, any>> {
    // (undocumented)
    $and: WhereClause<T>[];
}

// @public (undocumented)
export type ApplyActionOptions = {
    $returnEdits?: true;
    $validateOnly?: false;
} | {
    $validateOnly?: true;
    $returnEdits?: false;
};

// @public (undocumented)
export type ApplyBatchActionOptions = {
    $returnEdits?: boolean;
};

// @public (undocumented)
export interface Attachment {
    fetchContents(): Promise<Blob>;
    fetchMetadata(): Promise<AttachmentMetadata>;
    // (undocumented)
    rid: string;
}

// @public (undocumented)
export interface AttachmentMetadata {
    // (undocumented)
    filename: string;
    // (undocumented)
    mediaType: string;
    // (undocumented)
    rid: string;
    // (undocumented)
    sizeBytes: string;
}

// @public
export interface AttachmentUpload extends Blob {
    // (undocumented)
    readonly name: string;
}

// @public (undocumented)
export type Augment<X extends ObjectOrInterfaceDefinition, T extends string> = X extends ObjectOrInterfaceDefinition<infer Z> ? Z extends BrandedApiName<infer ZZ, any> ? {
    [K in Z]: T[];
} : never : never;

// @public (undocumented)
export type Augments = Record<string, string[]>;

// @public (undocumented)
export interface BaseObjectSet<Q extends ObjectOrInterfaceDefinition> {
    // (undocumented)
    [ObjectSetType]: Q;
}

// Warning: (ae-forgotten-export) The symbol "ApiNameAsString" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DropDollarOptions" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type ConvertProps<FROM extends ObjectTypeDefinition<any> | InterfaceDefinition<any, any>, TO extends ValidToFrom<FROM>, P extends string = "$all"> = TO extends FROM ? P : TO extends ObjectTypeDefinition<any> ? ((UnionIfTrue<UnionIfTrue<NonNullable<TO["interfaceMap"]>[ApiNameAsString<FROM>][P extends "$all" ? (keyof FROM["properties"] extends NonNullable<keyof TO["interfaceMap"]>[ApiNameAsString<FROM>] ? keyof FROM["properties"] : never) : DropDollarOptions<P>], P extends "$notStrict" ? true : false, "$notStrict">, P extends "$rid" ? true : false, "$rid">)) : UnionIfTrue<UnionIfTrue<TO extends InterfaceDefinition<any> ? P extends "$all" ? "$all" : FROM extends ObjectTypeDefinition<any> ? DropDollarOptions<P> extends keyof NonNullable<FROM["inverseInterfaceMap"]>[ApiNameAsString<TO>] ? NonNullable<FROM["inverseInterfaceMap"]>[ApiNameAsString<TO>][DropDollarOptions<P>] : never : never : never, P extends "$notStrict" ? true : false, "$notStrict">, P extends "$rid" ? true : false, "$rid">;

// @public
export interface DataValueClientToWire {
    // (undocumented)
    attachment: string | AttachmentUpload;
    // (undocumented)
    boolean: boolean;
    // (undocumented)
    byte: number;
    // (undocumented)
    datetime: string;
    // (undocumented)
    decimal: string | number;
    // (undocumented)
    double: number;
    // (undocumented)
    float: number;
    // (undocumented)
    integer: number;
    // (undocumented)
    long: string | number;
    // (undocumented)
    marking: string;
    // (undocumented)
    null: null;
    // (undocumented)
    set: Set<any>;
    // (undocumented)
    short: number;
    // (undocumented)
    string: string;
    // (undocumented)
    struct: Record<string, any>;
    // (undocumented)
    threeDimensionalAggregation: {
        key: AllowedBucketKeyTypes;
        groups: {
            key: AllowedBucketKeyTypes;
            value: AllowedBucketTypes;
        }[];
    }[];
    // (undocumented)
    timestamp: string;
    // (undocumented)
    twoDimensionalAggregation: {
        key: AllowedBucketKeyTypes;
        value: AllowedBucketTypes;
    }[];
}

// @public
export interface DataValueWireToClient {
    // (undocumented)
    attachment: Attachment;
    // (undocumented)
    boolean: boolean;
    // (undocumented)
    byte: number;
    // (undocumented)
    datetime: string;
    // (undocumented)
    decimal: string;
    // (undocumented)
    double: number;
    // (undocumented)
    float: number;
    // (undocumented)
    integer: number;
    // (undocumented)
    long: string;
    // (undocumented)
    marking: string;
    // (undocumented)
    null: null;
    // (undocumented)
    set: Set<any>;
    // (undocumented)
    short: number;
    // (undocumented)
    string: string;
    // (undocumented)
    struct: Record<string, any>;
    // (undocumented)
    threeDimensionalAggregation: {
        key: AllowedBucketKeyTypes;
        groups: {
            key: AllowedBucketKeyTypes;
            value: AllowedBucketTypes;
        }[];
    }[];
    // (undocumented)
    timestamp: string;
    // (undocumented)
    twoDimensionalAggregation: {
        key: AllowedBucketKeyTypes;
        value: AllowedBucketTypes;
    }[];
}

// @public (undocumented)
export type DefaultToFalse<B extends boolean | undefined> = false extends B ? false : undefined extends B ? false : true;

// @public (undocumented)
export const DistanceUnitMapping: {
    centimeter: "CENTIMETERS";
    centimeters: "CENTIMETERS";
    cm: "CENTIMETERS";
    meter: "METERS";
    meters: "METERS";
    m: "METERS";
    kilometer: "KILOMETERS";
    kilometers: "KILOMETERS";
    km: "KILOMETERS";
    inch: "INCHES";
    inches: "INCHES";
    foot: "FEET";
    feet: "FEET";
    yard: "YARDS";
    yards: "YARDS";
    mile: "MILES";
    miles: "MILES";
    nautical_mile: "NAUTICAL_MILES";
    nauticalMile: "NAUTICAL_MILES";
    "nautical miles": "NAUTICAL_MILES";
};

// @public (undocumented)
export const DurationMapping: {
    quarter: "QUARTERS";
    quarters: "QUARTERS";
    sec: "SECONDS";
    seconds: "SECONDS";
    min: "MINUTES";
    minute: "MINUTES";
    minutes: "MINUTES";
    hr: "HOURS";
    hrs: "HOURS";
    hour: "HOURS";
    hours: "HOURS";
    day: "DAYS";
    days: "DAYS";
    wk: "WEEKS";
    week: "WEEKS";
    weeks: "WEEKS";
    mos: "MONTHS";
    month: "MONTHS";
    months: "MONTHS";
    yr: "YEARS";
    year: "YEARS";
    years: "YEARS";
};

// @public (undocumented)
export interface FetchInterfacePageArgs<Q extends InterfaceDefinition<any, any>, K extends ObjectOrInterfacePropertyKeysFrom2<Q> = ObjectOrInterfacePropertyKeysFrom2<Q>, R extends boolean = false> extends SelectArg<Q, K, R>, OrderByArg<Q, ObjectOrInterfacePropertyKeysFrom2<Q>> {
    // (undocumented)
    $augment?: Augments;
    // (undocumented)
    $nextPageToken?: string;
    // (undocumented)
    $pageSize?: number;
}

// @public (undocumented)
export interface FetchPageArgs<Q extends ObjectOrInterfaceDefinition, K extends ObjectOrInterfacePropertyKeysFrom2<Q> = ObjectOrInterfacePropertyKeysFrom2<Q>, R extends boolean = false, A extends Augments = {}, S extends NullabilityAdherence = NullabilityAdherenceDefault> extends SelectArg<Q, K, R, S>, OrderByArg<Q, ObjectOrInterfacePropertyKeysFrom2<Q>> {
    // (undocumented)
    $augment?: A;
    // (undocumented)
    $nextPageToken?: string;
    // (undocumented)
    $pageSize?: number;
}

// @public (undocumented)
export type FetchPageResult<Q extends ObjectOrInterfaceDefinition, L extends ObjectOrInterfacePropertyKeysFrom2<Q>, R extends boolean, S extends NullabilityAdherence> = PageResult<SingleOsdkResult<Q, L, R, S>>;

// @public (undocumented)
export type GeoFilter = GeoFilter_Within | GeoFilter_Intersects;

// @public (undocumented)
export type GeoFilter_Intersects = {
    "$intersects": {
        $bbox: BBox;
        $polygon?: never;
    } | BBox | {
        $polygon: Polygon["coordinates"];
        $bbox?: never;
    } | Polygon;
};

// @public (undocumented)
export type GeoFilter_Within = {
    "$within": {
        $distance: [number, keyof typeof DistanceUnitMapping];
        $of: [number, number] | Readonly<Point>;
        $bbox?: never;
        $polygon?: never;
    } | {
        $bbox: BBox;
        $distance?: never;
        $of?: never;
        $polygon?: never;
    } | BBox | {
        $polygon: Polygon["coordinates"];
        $bbox?: never;
        $distance?: never;
        $of?: never;
    } | Polygon;
};

// Warning: (ae-forgotten-export) The symbol "GroupByEntry" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type GroupByClause<Q extends ObjectOrInterfaceDefinition<any, any>> = {
    [P in AggregatableKeys<Q>]?: GroupByEntry<Q, P>;
};

// @public (undocumented)
export type GroupByRange<T> = [T, T];

// @public (undocumented)
export interface InterfaceObjectSet<Q extends InterfaceDefinition<any, any>> extends MinimalObjectSet<Q> {
}

// Warning: (ae-forgotten-export) The symbol "OkResult" needs to be exported by the entry point index.d.ts
//
// @public
export function isOk<X>(a: Result<X>): a is OkResult<X>;

// @public (undocumented)
export type LinkedType<Q extends ObjectOrInterfaceDefinition, L extends keyof Q["links"] & string> = NonNullable<Q["links"][L]["__OsdkLinkTargetType"]>;

// @public (undocumented)
export type LinkNames<Q extends ObjectOrInterfaceDefinition> = keyof Q["links"] & string;

// @public (undocumented)
export interface MinimalObjectSet<Q extends ObjectOrInterfaceDefinition> extends BaseObjectSet<Q> {
    // Warning: (tsdoc-malformed-inline-tag) Expecting a TSDoc tag starting with "{@"
    // Warning: (tsdoc-escape-right-brace) The "}" character should be escaped using a backslash to avoid confusion with a TSDoc inline tag
    asyncIter: () => AsyncIterableIterator<Osdk<Q, "$all">>;
    // Warning: (tsdoc-malformed-inline-tag) Expecting a TSDoc tag starting with "{@"
    // Warning: (tsdoc-escape-right-brace) The "}" character should be escaped using a backslash to avoid confusion with a TSDoc inline tag
    fetchPage: <L extends ObjectOrInterfacePropertyKeysFrom2<Q>, R extends boolean, const A extends Augments, S extends NullabilityAdherence = NullabilityAdherenceDefault>(args?: FetchPageArgs<Q, L, R, A, S>) => Promise<FetchPageResult<Q, L, R, S>>;
    // Warning: (tsdoc-malformed-inline-tag) Expecting a TSDoc tag starting with "{@"
    // Warning: (tsdoc-escape-right-brace) The "}" character should be escaped using a backslash to avoid confusion with a TSDoc inline tag
    // Warning: (tsdoc-malformed-inline-tag) Expecting a TSDoc tag starting with "{@"
    // Warning: (tsdoc-escape-right-brace) The "}" character should be escaped using a backslash to avoid confusion with a TSDoc inline tag
    fetchPageWithErrors: <L extends ObjectOrInterfacePropertyKeysFrom2<Q>, R extends boolean, const A extends Augments, S extends NullabilityAdherence = NullabilityAdherenceDefault>(args?: FetchPageArgs<Q, L, R, A, S>) => Promise<Result<FetchPageResult<Q, L, R, S>>>;
    // Warning: (tsdoc-malformed-inline-tag) Expecting a TSDoc tag starting with "{@"
    // Warning: (tsdoc-escape-right-brace) The "}" character should be escaped using a backslash to avoid confusion with a TSDoc inline tag
    // Warning: (tsdoc-malformed-inline-tag) Expecting a TSDoc tag starting with "{@"
    // Warning: (tsdoc-escape-right-brace) The "}" character should be escaped using a backslash to avoid confusion with a TSDoc inline tag
    // Warning: (tsdoc-malformed-inline-tag) Expecting a TSDoc tag starting with "{@"
    // Warning: (tsdoc-escape-right-brace) The "}" character should be escaped using a backslash to avoid confusion with a TSDoc inline tag
    where: (clause: WhereClause<Q>) => MinimalObjectSet<Q>;
}

// @public (undocumented)
export type NOOP<T> = T extends (...args: any[]) => any ? T : T extends abstract new (...args: any[]) => any ? T : {
    [K in keyof T]: T[K];
};

// @public (undocumented)
export interface NotWhereClause<T extends ObjectOrInterfaceDefinition<any, any>> {
    // (undocumented)
    $not: WhereClause<T>;
}

// @public (undocumented)
export type NullabilityAdherence = false | "throw" | "drop";

// @public (undocumented)
export type NullabilityAdherenceDefault = "throw";

// @public (undocumented)
export type NumericAggregateOption = "min" | "max" | "sum" | "avg" | "approximateDistinct";

// @public (undocumented)
export interface ObjectSet<Q extends ObjectOrInterfaceDefinition> extends MinimalObjectSet<Q> {
    // Warning: (tsdoc-malformed-inline-tag) Expecting a TSDoc tag starting with "{@"
    // Warning: (tsdoc-malformed-inline-tag) Expecting a TSDoc tag starting with "{@"
    // Warning: (tsdoc-escape-right-brace) The "}" character should be escaped using a backslash to avoid confusion with a TSDoc inline tag
    // Warning: (tsdoc-malformed-inline-tag) Expecting a TSDoc tag starting with "{@"
    // Warning: (tsdoc-malformed-inline-tag) Expecting a TSDoc tag starting with "{@"
    // Warning: (tsdoc-escape-right-brace) The "}" character should be escaped using a backslash to avoid confusion with a TSDoc inline tag
    // Warning: (tsdoc-escape-right-brace) The "}" character should be escaped using a backslash to avoid confusion with a TSDoc inline tag
    // Warning: (tsdoc-escape-right-brace) The "}" character should be escaped using a backslash to avoid confusion with a TSDoc inline tag
    aggregate: <AO extends AggregateOpts<Q>>(req: AggregateOptsThatErrorsAndDisallowsOrderingWithMultipleGroupBy<Q, AO>) => Promise<AggregationsResults<Q, AO>>;
    fetchOne: Q extends ObjectTypeDefinition<any> ? <L extends ObjectOrInterfacePropertyKeysFrom2<Q>, R extends boolean, S extends false | "throw" = NullabilityAdherenceDefault>(primaryKey: PropertyValueClientToWire[Q["primaryKeyType"]], options?: SelectArg<Q, L, R, S>) => Promise<SingleOsdkResult<Q, L, R, S>> : never;
    fetchOneWithErrors: Q extends ObjectTypeDefinition<any> ? <L extends ObjectOrInterfacePropertyKeysFrom2<Q>, R extends boolean, S extends false | "throw" = NullabilityAdherenceDefault>(primaryKey: PropertyValueClientToWire[Q["primaryKeyType"]], options?: SelectArg<Q, L, R, S>) => Promise<Result<SingleOsdkResult<Q, L, R, S>>> : never;
    intersect: (...objectSets: ReadonlyArray<ObjectSet<Q>>) => ObjectSet<Q>;
    pivotTo: <L extends LinkNames<Q>>(type: L) => ObjectSet<LinkedType<Q, L>>;
    subtract: (...objectSets: ReadonlyArray<ObjectSet<Q>>) => ObjectSet<Q>;
    union: (...objectSets: ReadonlyArray<ObjectSet<Q>>) => ObjectSet<Q>;
    // Warning: (tsdoc-malformed-inline-tag) Expecting a TSDoc tag starting with "{@"
    // Warning: (tsdoc-escape-right-brace) The "}" character should be escaped using a backslash to avoid confusion with a TSDoc inline tag
    // Warning: (tsdoc-malformed-inline-tag) Expecting a TSDoc tag starting with "{@"
    // Warning: (tsdoc-escape-right-brace) The "}" character should be escaped using a backslash to avoid confusion with a TSDoc inline tag
    // Warning: (tsdoc-malformed-inline-tag) Expecting a TSDoc tag starting with "{@"
    // Warning: (tsdoc-escape-right-brace) The "}" character should be escaped using a backslash to avoid confusion with a TSDoc inline tag
    where: (clause: WhereClause<Q>) => ObjectSet<Q>;
}

// @public (undocumented)
export interface OrderByArg<Q extends ObjectOrInterfaceDefinition<any, any>, L extends ObjectOrInterfacePropertyKeysFrom2<Q> = ObjectOrInterfacePropertyKeysFrom2<Q>> {
    // (undocumented)
    $orderBy?: {
        [K in L]?: "asc" | "desc";
    };
}

// @public (undocumented)
export type OrderedAggregationClause<Q extends ObjectOrInterfaceDefinition> = {
    [AK in ValidAggregationKeys<Q>]?: "unordered" | "asc" | "desc";
};

// @public (undocumented)
export interface OrWhereClause<T extends ObjectOrInterfaceDefinition<any, any>> {
    // (undocumented)
    $or: WhereClause<T>[];
}

// Warning: (ae-forgotten-export) The symbol "IsNever" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type Osdk<Q extends ObjectTypeDefinition<any> | InterfaceDefinition<any, any>, P extends string = "$all", Z extends string = never> = OsdkBase<Q> & {
    [PP in keyof Q["properties"] as (IsNever<P> extends true ? PP : P extends "$all" ? PP : PP extends P ? PP : never)]: IsNever<P> extends true ? OsdkObjectPropertyType<Q["properties"][PP], false> : OsdkObjectPropertyType<Q["properties"][PP], P extends "$notStrict" ? false : true>;
} & {
    __apiName: Q["apiName"] & {
        __OsdkType?: Q["apiName"];
    };
    __primaryKey: Q extends ObjectTypeDefinition<any> ? OsdkObjectPrimaryKeyType<Q> : string | number | boolean;
    $link: Q extends ObjectTypeDefinition<any> ? OsdkObjectLinksObject<Q> : never;
    $as: <NEW_Q extends ValidToFrom<Q>>(type: NEW_Q | string) => Osdk<NEW_Q, ConvertProps<Q, NEW_Q, P>, UnderlyingProps<Q, P, Z, NEW_Q>>;
} & (IsNever<P> extends true ? {} : string extends P ? {} : "$rid" extends P ? {
    $rid: string;
} : {});

// @public (undocumented)
export type OsdkBase<Q extends ObjectTypeDefinition<any> | InterfaceDefinition<any, any>> = {
    $apiName: Q["apiName"] & {
        __OsdkType?: Q["apiName"];
    };
    $objectType: string;
    $primaryKey: Q extends ObjectTypeDefinition<any> ? OsdkObjectPrimaryKeyType<Q> : (string | number);
    $title: string | undefined;
};

// @public (undocumented)
export type OsdkObject<N extends string> = {
    $apiName: N;
    $objectType: string;
    $primaryKey: unknown;
};

// @public (undocumented)
export type OsdkObjectLinksEntry<O extends ObjectTypeDefinition<any>, L extends ObjectTypeLinkKeysFrom2<O>> = O["links"][L] extends ObjectTypeLinkDefinition<infer T, infer M> ? (M extends false ? SingleLinkAccessor<T> : ObjectSet<T>) : never;

// @public
export type OsdkObjectLinksObject<O extends ObjectTypeDefinition<any>> = ObjectTypeLinkKeysFrom2<O> extends never ? never : {
    [L in ObjectTypeLinkKeysFrom2<O>]: OsdkObjectLinksEntry<O, L>;
};

// @public (undocumented)
export type OsdkObjectOrInterfaceFrom<Q extends ObjectTypeDefinition<any> | InterfaceDefinition<any, any>, P extends string = "$all"> = Osdk<Q, P>;

// @public (undocumented)
export type OsdkObjectPrimaryKeyType<O extends ObjectTypeDefinition<any>> = PropertyValueWireToClient[O["primaryKeyType"]];

// Warning: (tsdoc-param-tag-missing-hyphen) The @param block should be followed by a parameter name and then a hyphen
// Warning: (tsdoc-param-tag-with-invalid-type) The @param block should not include a JSDoc-style '{type}'
// Warning: (tsdoc-param-tag-missing-hyphen) The @param block should be followed by a parameter name and then a hyphen
// Warning: (tsdoc-param-tag-with-invalid-type) The @param block should not include a JSDoc-style '{type}'
// Warning: (ae-forgotten-export) The symbol "MaybeArray" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Converted" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "MaybeNullable" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type OsdkObjectPropertyType<T extends ObjectTypePropertyDefinition, STRICTLY_ENFORCE_NULLABLE extends boolean = true> = STRICTLY_ENFORCE_NULLABLE extends false ? MaybeArray<T, Converted<PropertyValueWireToClient[T["type"]]>> | undefined : MaybeNullable<T, MaybeArray<T, Converted<PropertyValueWireToClient[T["type"]]>>>;

// @public (undocumented)
export interface PageResult<T extends OsdkObject<any>> {
    // (undocumented)
    data: T[];
    // (undocumented)
    nextPageToken: string | undefined;
}

// @public (undocumented)
export type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

// @public (undocumented)
export type PossibleWhereClauseFilters = "$gt" | "$eq" | "$ne" | "$isNull" | "$contains" | "$gte" | "$lt" | "$lte" | "$within" | "$intersects" | "$startsWith" | "$containsAllTermsInOrder" | "$containsAnyTerm" | "$containsAllTerms";

// @public
export interface PropertyValueClientToWire {
    // (undocumented)
    attachment: string | AttachmentUpload;
    // (undocumented)
    boolean: boolean;
    // (undocumented)
    byte: number;
    // (undocumented)
    datetime: string;
    // (undocumented)
    decimal: string | number;
    // (undocumented)
    double: number;
    // (undocumented)
    float: number;
    // (undocumented)
    geopoint: GeoJSON.Point;
    // (undocumented)
    geoshape: GeoJSON.GeoJSON;
    // (undocumented)
    integer: number;
    // (undocumented)
    long: string | number;
    // (undocumented)
    marking: string;
    // (undocumented)
    numericTimeseries: TimeSeriesProperty<number>;
    // (undocumented)
    short: number;
    // (undocumented)
    string: string;
    // (undocumented)
    stringTimeseries: TimeSeriesProperty<string>;
    // (undocumented)
    timestamp: string;
}

// @public
export interface PropertyValueWireToClient {
    // (undocumented)
    attachment: Attachment;
    // (undocumented)
    boolean: boolean;
    // (undocumented)
    byte: number;
    // (undocumented)
    datetime: string;
    // (undocumented)
    decimal: string;
    // (undocumented)
    double: number;
    // (undocumented)
    float: number;
    // (undocumented)
    geopoint: GeoJSON.Point;
    // (undocumented)
    geoshape: GeoJSON.GeoJSON;
    // (undocumented)
    integer: number;
    // (undocumented)
    long: string;
    // (undocumented)
    marking: string;
    // (undocumented)
    numericTimeseries: TimeSeriesProperty<number>;
    // (undocumented)
    short: number;
    // (undocumented)
    string: string;
    // (undocumented)
    stringTimeseries: TimeSeriesProperty<string>;
    // (undocumented)
    timestamp: string;
}

// Warning: (ae-forgotten-export) The symbol "PartialByNotStrict" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "NotOptionalParams" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "OptionalQueryParams" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type QueryParameterType<T extends Record<any, QueryDataTypeDefinition<any, any>>> = PartialByNotStrict<NotOptionalParams<T>, OptionalQueryParams<T>>;

// @public (undocumented)
export type QueryReturnType<T extends QueryDataTypeDefinition<any, any>> = T extends ObjectQueryDataType<any, infer TTargetType> ? OsdkBase<TTargetType> : T extends ObjectSetQueryDataType<any, infer TTargetType> ? ObjectSet<TTargetType> : T["type"] extends keyof DataValueWireToClient ? DataValueWireToClient[T["type"]] : never;

// @public (undocumented)
export type QuerySignatureFromDef<T extends QueryDefinition<any, any>> = {
    executeFunction: keyof T["parameters"] extends never ? () => Promise<QueryReturnType<T["output"]>> : (params: QueryParameterType<T["parameters"]>) => Promise<QueryReturnType<T["output"]>>;
};

// @public
export type RespectNullability<S extends NullabilityAdherence> = S extends false ? false : true;

// Warning: (ae-forgotten-export) The symbol "ErrorResult" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type Result<V> = OkResult<V> | ErrorResult;

// @public (undocumented)
export interface SelectArg<Q extends ObjectOrInterfaceDefinition<any, any>, L extends ObjectOrInterfacePropertyKeysFrom2<Q> = ObjectOrInterfacePropertyKeysFrom2<Q>, R extends boolean = false, S extends NullabilityAdherence = NullabilityAdherenceDefault> {
    // (undocumented)
    $__EXPERIMENTAL_strictNonNull?: S;
    // (undocumented)
    $includeRid?: R;
    // (undocumented)
    $select?: readonly L[];
}

// @public (undocumented)
export type SelectArgToKeys<Q extends ObjectOrInterfaceDefinition, A extends SelectArg<Q, any, any>> = A extends SelectArg<Q, never> ? "$all" : A["$select"] extends readonly string[] ? A["$select"][number] : "$all";

// @public (undocumented)
export interface SingleLinkAccessor<T extends ObjectTypeDefinition<any>> {
    fetchOne: <const A extends SelectArg<T, ObjectOrInterfacePropertyKeysFrom2<T>, boolean>>(options?: A) => Promise<DefaultToFalse<A["$includeRid"]> extends false ? Osdk<T, SelectArgToKeys<T, A>> : Osdk<T, SelectArgToKeys<T, A> | "$rid">>;
    fetchOneWithErrors: <const A extends SelectArg<T, ObjectOrInterfacePropertyKeysFrom2<T>, boolean>>(options?: A) => Promise<Result<DefaultToFalse<A["$includeRid"]> extends false ? Osdk<T, SelectArgToKeys<T, A>> : Osdk<T, SelectArgToKeys<T, A> | "$rid">>>;
}

// @public (undocumented)
export type SingleOsdkResult<Q extends ObjectOrInterfaceDefinition, L extends ObjectOrInterfacePropertyKeysFrom2<Q>, R extends boolean, S extends NullabilityAdherence> = ObjectOrInterfacePropertyKeysFrom2<Q> extends L ? ([
DefaultToFalse<R>,
RespectNullability<S>
] extends [false, true] ? Osdk<Q> : Osdk<Q, UnionIfTrue<UnionIfFalse<"$all", RespectNullability<S>, "$notStrict">, DefaultToFalse<R>, "$rid">>) : ([DefaultToFalse<R>, RespectNullability<S>] extends [false, true] ? Osdk<Q, L> : Osdk<Q, UnionIfTrue<UnionIfFalse<L, RespectNullability<S>, "$notStrict">, DefaultToFalse<R>, "$rid">>);

// @public (undocumented)
export type StringAggregateOption = "approximateDistinct";

// @public (undocumented)
export const TimeseriesDurationMapping: {
    sec: "SECONDS";
    seconds: "SECONDS";
    min: "MINUTES";
    minute: "MINUTES";
    minutes: "MINUTES";
    hr: "HOURS";
    hrs: "HOURS";
    hour: "HOURS";
    hours: "HOURS";
    day: "DAYS";
    days: "DAYS";
    wk: "WEEKS";
    week: "WEEKS";
    weeks: "WEEKS";
    mos: "MONTHS";
    month: "MONTHS";
    months: "MONTHS";
    yr: "YEARS";
    year: "YEARS";
    years: "YEARS";
    ms: "MILLISECONDS";
    milliseconds: "MILLISECONDS";
};

// @public (undocumented)
export interface TimeSeriesPoint<T extends string | number> {
    // (undocumented)
    time: string;
    // (undocumented)
    value: T;
}

// @public (undocumented)
export interface TimeSeriesProperty<T extends number | string> {
    // Warning: (tsdoc-malformed-inline-tag) Expecting a TSDoc tag starting with "{@"
    // Warning: (tsdoc-escape-right-brace) The "}" character should be escaped using a backslash to avoid confusion with a TSDoc inline tag
    // Warning: (tsdoc-malformed-inline-tag) Expecting a TSDoc tag starting with "{@"
    // Warning: (tsdoc-escape-right-brace) The "}" character should be escaped using a backslash to avoid confusion with a TSDoc inline tag
    asyncIterPoints(query?: TimeSeriesQuery): AsyncGenerator<TimeSeriesPoint<T>>;
    // Warning: (tsdoc-malformed-inline-tag) Expecting a TSDoc tag starting with "{@"
    // Warning: (tsdoc-escape-right-brace) The "}" character should be escaped using a backslash to avoid confusion with a TSDoc inline tag
    getAllPoints(query?: TimeSeriesQuery): Promise<Array<TimeSeriesPoint<T>>>;
    getFirstPoint(): Promise<TimeSeriesPoint<T>>;
    getLastPoint(): Promise<TimeSeriesPoint<T>>;
}

// @public (undocumented)
export type TimeSeriesQuery = {
    $before: number;
    $unit: keyof typeof TimeseriesDurationMapping;
    $after?: never;
    $startTime?: never;
    $endTime?: never;
} | {
    $after: number;
    $unit: keyof typeof TimeseriesDurationMapping;
    $before?: never;
    $startTime?: never;
    $endTime?: never;
} | {
    $startTime: string;
    $endTime?: string;
    $before?: never;
    $after?: never;
    $unit?: never;
} | {
    $startTime?: string;
    $endTime: string;
    $before?: never;
    $after?: never;
    $unit?: never;
};

// @public
export type UnionIfFalse<S extends string, JUST_S_IF_TRUE extends boolean, E> = IsNever<S> extends true ? never : JUST_S_IF_TRUE extends true ? S : S | E;

// @public
export type UnionIfTrue<S extends string, UNION_IF_TRUE extends boolean, E extends string> = IsNever<S> extends true ? never : UNION_IF_TRUE extends true ? S | E : S;

// @public (undocumented)
export type UnorderedAggregationClause<Q extends ObjectOrInterfaceDefinition> = {
    [AK in ValidAggregationKeys<Q>]?: "unordered";
};

// Warning: (ae-forgotten-export) The symbol "AGG_FOR_TYPE" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type ValidAggregationKeys<Q extends ObjectOrInterfaceDefinition> = keyof ({
    [KK in AggregatableKeys<Q> as `${KK & string}:${AGG_FOR_TYPE<PropertyValueClientToWire[Q["properties"][KK]["type"]]>}`]?: any;
} & {
    $count?: any;
});

// @public
export type ValidToFrom<FROM extends ObjectOrInterfaceDefinition> = FROM extends InterfaceDefinition<any, any> ? ObjectTypeDefinition<any> | InterfaceDefinition<any, any> : InterfaceDefinition<any, any>;

// Warning: (ae-forgotten-export) The symbol "FilterFor" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type WhereClause<T extends ObjectOrInterfaceDefinition<any, any>> = OrWhereClause<T> | AndWhereClause<T> | NotWhereClause<T> | {
    [P in keyof T["properties"]]?: FilterFor<T["properties"][P]>;
};

// Warnings were encountered during analysis:
//
// src/OsdkObjectFrom.ts:100:4 - (tsdoc-param-tag-missing-hyphen) The @param block should be followed by a parameter name and then a hyphen
// src/OsdkObjectFrom.ts:101:4 - (tsdoc-param-tag-missing-hyphen) The @param block should be followed by a parameter name and then a hyphen
// src/OsdkObjectFrom.ts:157:5 - (ae-forgotten-export) The symbol "UnderlyingProps" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
