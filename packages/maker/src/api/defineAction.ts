/*
 * Copyright 2025 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type {
  OntologyIrInterfacePropertyLogicRuleValue,
  OntologyIrParameterPrefill,
  ParameterId,
} from "@osdk/client.unstable";
import invariant from "tiny-invariant";
import { convertConditionDefinition } from "../conversion/toMarketplace/convertConditionDefinition.js";
import type { ActionLevelValidationDefinition } from "./action/ActionLevelValidationDefinition.js";
import { type ActionParameter } from "./action/ActionParameter.js";
import type { ActionParameterAllowedValues } from "./action/ActionParameterAllowedValues.js";
import type { ActionParameterConfiguration } from "./action/ActionParameterConfiguration.js";
import {
  type ActionParameterType,
  type ActionParameterTypePrimitive,
  isActionParameterTypePrimitive,
} from "./action/ActionParameterType.js";
import type { ActionSection } from "./action/ActionSection.js";
import type { ActionStatus } from "./action/ActionStatus.js";
import { type ActionType } from "./action/ActionType.js";
import type { ActionValidationRule } from "./action/ActionValidationRule.js";
import type { ConditionDefinition } from "./action/ConditionDefinition.js";
import type { DefaultFormat } from "./action/DefaultFormat.js";
import type { MappingValue } from "./action/MappingValue.js";
import type { SubmissionMetadata } from "./action/SubmissionMetadata.js";
import type { TableConfiguration } from "./action/TableConfiguration.js";
import type { BlueprintIcon } from "./common/BlueprintIcons.js";
import { OntologyEntityTypeEnum } from "./common/OntologyEntityTypeEnum.js";
import { uppercaseFirstLetter } from "./defineObject.js";
import {
  addNamespaceIfNone,
  importedTypes,
  namespace,
  ontologyDefinition,
  updateOntology,
  withoutNamespace,
} from "./defineOntology.js";
import { getFlattenedInterfaceProperties } from "./interface/getFlattenedInterfaceProperties.js";
import {
  getInterfacePropertyTypeType,
  type InterfaceDefinedProperty,
  type InterfacePropertyType,
  isInterfaceSharedPropertyType,
} from "./interface/InterfacePropertyType.js";
import type { InterfaceType } from "./interface/InterfaceType.js";
import type { ObjectPropertyType } from "./object/ObjectPropertyType.js";
import type { ObjectPropertyTypeUserDefinition } from "./object/ObjectPropertyTypeUserDefinition.js";
import type { ObjectTypeDefinition } from "./object/ObjectTypeDefinition.js";
import {
  isStruct,
  type PropertyTypeType,
} from "./properties/PropertyTypeType.js";

export const MODIFY_OBJECT_PARAMETER: string = "objectToModifyParameter";

export const CREATE_OR_MODIFY_OBJECT_PARAMETER: string =
  "objectToCreateOrModifyParameter";

export const DELETE_OBJECT_PARAMETER: string = "objectToDeleteParameter";

export const CREATE_INTERFACE_OBJECT_PARAMETER: string = "objectTypeParameter";

export const MODIFY_INTERFACE_OBJECT_PARAMETER: string =
  "interfaceObjectToModifyParameter";

export type ActionTypeDefinition = Omit<ActionType, "__type">;

export type ActionTypeUserDefinition = {
  objectType: ObjectTypeDefinition;
  apiName?: string;
  displayName?: string;
  status?: ActionStatus;
  parameterConfiguration?: Record<string, ActionParameterConfiguration>;
  nonParameterMappings?: Record<string, MappingValue>;
  actionLevelValidation?: ActionLevelValidationDefinition;
  excludedProperties?: Array<ParameterId>;
  sections?: Array<ActionSection>;
  defaultFormat?: DefaultFormat;
  enableLayoutSwitch?: boolean;
  tableConfiguration?: TableConfiguration;
  parameterOrdering?: Array<string>;
  submissionMetadata?: SubmissionMetadata;
  // Used for Create or Modify actions
  primaryKeyOption?: "autoGenerated" | "userInput";
  icon?: { locator: BlueprintIcon; color: string };
};

export type InterfaceActionTypeUserDefinition = {
  interfaceType: InterfaceType;
  objectType?: ObjectTypeDefinition;
  apiName?: string;
  displayName?: string;
  status?: ActionStatus;
  parameterConfiguration?: Record<string, ActionParameterConfiguration>;
  nonParameterMappings?: Record<string, MappingValue>;
  actionLevelValidation?: ActionLevelValidationDefinition;
  excludedProperties?: Array<string>;
  sections?: Array<ActionSection>;
  defaultFormat?: DefaultFormat;
  enableLayoutSwitch?: boolean;
  tableConfiguration?: TableConfiguration;
  parameterOrdering?: Array<string>;
  submissionMetadata?: SubmissionMetadata;
  // Use the below options for Java OSDK compatibility
  useNonNamespacedParameters?: boolean;
  conflictingParameterOverrides?: Record<string, string>;
  icon?: { locator: BlueprintIcon; color: string };
};

export function defineAction(actionDef: ActionTypeDefinition): ActionType {
  const apiName = namespace + actionDef.apiName;
  const parameterIds = (actionDef.parameters ?? []).map(p => p.id);

  if (
    ontologyDefinition[OntologyEntityTypeEnum.ACTION_TYPE][apiName]
      !== undefined
  ) {
    throw new Error(
      `Action type with apiName ${actionDef.apiName} is already defined`,
    );
  }
  invariant(
    /^[a-z0-9]+(-[a-z0-9]+)*$/.test(actionDef.apiName),
    `Action type apiName "${actionDef.apiName}" must be alphanumeric, lowercase, and kebab-case`,
  );

  const parameterIdsSet = new Set(parameterIds);
  invariant(
    parameterIdsSet.size === parameterIds.length,
    `Parameter ids must be unique`,
  );

  const parameterIdsNotFound = Array.from(referencedParameterIds(actionDef))
    .filter(p => !parameterIdsSet.has(p));
  invariant(
    parameterIdsNotFound.length === 0,
    `Parameters ${
      JSON.stringify(parameterIdsNotFound)
    } were referenced but not defined`,
  );

  const definedSectionIds = new Set(Object.keys(actionDef.sections ?? []));
  const undefinedSectionsInOrdering = (actionDef.formContentOrdering ?? [])
    .flatMap(
      s => s.type === "parameterId" ? [] : [s.sectionId],
    ).filter(sId => !definedSectionIds.has(sId));
  invariant(
    undefinedSectionsInOrdering.length === 0,
    `Sections [${undefinedSectionsInOrdering}] were referenced in content ordering but not defined`,
  );

  invariant(
    actionDef.rules.length > 0,
    `Action type ${actionDef.apiName} must have at least one logic rule`,
  );
  actionDef.rules.forEach(rule => {
    if (rule.type === "modifyObjectRule") {
      invariant(
        parameterIds.some(id => id === rule.modifyObjectRule.objectToModify),
        `Object to modify parameter must be defined in parameters`,
      );
    }
    if (rule.type === "deleteObjectRule") {
      invariant(
        parameterIds.some(id => id === rule.deleteObjectRule.objectToDelete),
        `Object to delete parameter must be defined in parameters`,
      );
    }
    if (rule.type === "modifyInterfaceRule") {
      // The there must be a parameter for the interface, and the interface there must exist
      const interfaceParam = actionDef.parameters!.find(p =>
        p.id === rule.modifyInterfaceRule.interfaceObjectToModifyParameter
      );
      invariant(
        interfaceParam !== undefined && typeof interfaceParam.type === "object"
          && (interfaceParam.type.type === "interfaceReference"
            || interfaceParam.type.type === "interfaceReferenceList"),
        `Interface object to modify parameter must be an interface reference`,
      );
      const interfaceReference =
        interfaceParam.type.type === "interfaceReference"
          ? interfaceParam.type.interfaceReference.interfaceTypeRid
          : interfaceParam.type.interfaceReferenceList.interfaceTypeRid;
      invariant(
        ontologyDefinition.INTERFACE_TYPE[interfaceReference] !== undefined
          || importedTypes.INTERFACE_TYPE[interfaceReference] !== undefined,
        `Interface type ${interfaceReference} does not exist`,
      );

      // All referenced SPTs must exist on the interface
      const interfaceType =
        ontologyDefinition.INTERFACE_TYPE[interfaceReference];
      Object.keys(rule.modifyInterfaceRule.sharedPropertyValues).forEach(
        spt => {
          invariant(
            Object.keys(getFlattenedInterfaceProperties(interfaceType))
              .includes(spt),
            `Shared property type ${spt} does not exist in interface type ${interfaceReference}`,
          );
        },
      );
    }
    if (rule.type === "addInterfaceRule") {
      // The referenced interface must exist globally
      const interfaceType = ontologyDefinition
        .INTERFACE_TYPE[rule.addInterfaceRule.interfaceApiName]
        ?? importedTypes.INTERFACE_TYPE[rule.addInterfaceRule.interfaceApiName];
      invariant(
        interfaceType !== undefined,
        `Interface type ${rule.addInterfaceRule.interfaceApiName} does not exist`,
      );

      // All referenced SPTs must exist on the interface
      Object.keys(rule.addInterfaceRule.sharedPropertyValues).forEach(spt => {
        invariant(
          Object.keys(getFlattenedInterfaceProperties(interfaceType)).includes(
            spt,
          ),
          `Shared property type ${spt} does not exist in interface type ${interfaceType.apiName}`,
        );
      });
    }
  });

  const fullAction = {
    ...actionDef,
    apiName: apiName,
    entities: actionDef.entities ?? {
      affectedInterfaceTypes: [],
      affectedObjectTypes: [],
      affectedLinkTypes: [],
      typeGroups: [],
    },
    __type: OntologyEntityTypeEnum.ACTION_TYPE,
  } as ActionType;
  validateActionConfiguration(fullAction);
  updateOntology(fullAction);
  return fullAction;
}

export function isPropertyParameter(
  def: ActionTypeUserDefinition | InterfaceActionTypeUserDefinition,
  name: string,
  type: PropertyTypeType,
): boolean {
  if ("interfaceType" in def) {
    return (Object.keys(getFlattenedInterfaceProperties(def.interfaceType))
      .includes(name)
      && !Object.keys(def.nonParameterMappings ?? {}).includes(name)
      && !isStruct(type)
      && !def.excludedProperties?.includes(name));
  }
  return (
    Object.keys(def.objectType.properties ?? {}).includes(name)
    && !Object.keys(def.nonParameterMappings ?? {}).includes(name)
    && !isStruct(type)
    && !def.excludedProperties?.includes(name)
  );
}

export function createParameters(
  def: ActionTypeUserDefinition | InterfaceActionTypeUserDefinition,
  propertyMap:
    | Record<string, ObjectPropertyTypeUserDefinition>
    | Record<string, InterfacePropertyType>,
  parameterSet: Set<string>,
  requiredMap?: Record<string, boolean>,
): Array<ActionParameter> {
  const targetParams = getTargetParameters(def, parameterSet);
  return [
    ...targetParams,
    ...Array.from(parameterSet).map(
      id => {
        let propertyMetadata = undefined;
        if (id in propertyMap) {
          propertyMetadata = "sharedPropertyType" in propertyMap[id]
            ? propertyMap[id].sharedPropertyType
            : propertyMap[id];
        }
        return {
          id,
          displayName: def.parameterConfiguration?.[id]?.displayName
            ?? propertyMetadata?.displayName
            ?? uppercaseFirstLetter(id),
          type: def.parameterConfiguration?.[id]?.customParameterType
            ?? extractActionParameterType(propertyMetadata!),
          validation: (def.parameterConfiguration?.[id] !== undefined)
            ? {
              ...def.parameterConfiguration?.[id],
              allowedValues: def.parameterConfiguration?.[id].allowedValues
                ?? (def.parameterConfiguration?.[id].customParameterType
                  ? extractAllowedValuesFromActionParameterType(
                    def.parameterConfiguration?.[id].customParameterType,
                  )
                  : extractAllowedValuesFromPropertyType(
                    propertyMetadata!.type,
                  )),
              required: def.parameterConfiguration?.[id].required
                ?? (propertyMetadata?.nullability?.noNulls
                  ?? false),
            }
            : {
              required: (propertyMetadata!.array ?? false)
                ? {
                  listLength: propertyMetadata!.nullability
                      ?.noEmptyCollections
                    ? { min: 1 }
                    : {},
                }
                : requiredMap?.[id]
                  ?? propertyMetadata?.nullability?.noNulls
                  ?? false,
              allowedValues: extractAllowedValuesFromPropertyType(
                propertyMetadata?.type!,
              ),
            },
          defaultValue: def.parameterConfiguration?.[id]?.defaultValue,
          description: def.parameterConfiguration?.[id]?.description,
          renderHint: def.parameterConfiguration?.[id]?.renderHint,
        };
      },
    ),
  ];
}

function getTargetParameters(
  def: ActionTypeUserDefinition | InterfaceActionTypeUserDefinition,
  parameterSet: Set<string>,
): Array<ActionParameter> {
  const targetParams: Array<ActionParameter> = [];
  parameterSet.forEach(name => {
    if (name === MODIFY_OBJECT_PARAMETER) {
      targetParams.push({
        id: MODIFY_OBJECT_PARAMETER,
        displayName: def.parameterConfiguration?.[name]?.displayName
          ?? "Modify object",
        type: (typeof def.parameterConfiguration?.[name]?.required === "object"
            && "listLength" in def.parameterConfiguration?.[name]?.required)
          ? {
            type: "objectReferenceList",
            objectReferenceList: { objectTypeId: def.objectType!.apiName },
          }
          : {
            type: "objectReference",
            objectReference: { objectTypeId: def.objectType!.apiName },
          },
        validation: {
          ...def.parameterConfiguration?.[name],
          allowedValues: { type: "objectQuery" },
          required: def.parameterConfiguration?.[name]?.required ?? true,
        },
        defaultValue: def.parameterConfiguration?.[name]?.defaultValue,
        description: def.parameterConfiguration?.[name]?.description,
      });
      parameterSet.delete(MODIFY_OBJECT_PARAMETER);
    }
    if (name === CREATE_OR_MODIFY_OBJECT_PARAMETER) {
      targetParams.push({
        id: CREATE_OR_MODIFY_OBJECT_PARAMETER,
        displayName: def.parameterConfiguration?.[name]?.displayName
          ?? "Create or modify object",
        type: {
          type: "objectReference",
          objectReference: {
            objectTypeId: def.objectType!.apiName,
            maybeCreateObjectOption: !("primaryKeyOption" in def)
              ? {
                type: "autoGenerated",
                autoGenerated: {},
              }
              : (def.primaryKeyOption === "autoGenerated")
              ? {
                type: "autoGenerated",
                autoGenerated: {},
              }
              : {
                type: "userInput",
                userInput: {},
              },
          },
        },
        validation: {
          ...def.parameterConfiguration?.[name],
          allowedValues: { type: "objectQuery" },
          required: def.parameterConfiguration?.[name]?.required ?? true,
        },
        defaultValue: def.parameterConfiguration?.[name]?.defaultValue,
        description: def.parameterConfiguration?.[name]?.description,
      });
      parameterSet.delete(CREATE_OR_MODIFY_OBJECT_PARAMETER);
    }
    if (name === DELETE_OBJECT_PARAMETER && !("interfaceType" in def)) {
      targetParams.push({
        id: DELETE_OBJECT_PARAMETER,
        displayName: def.parameterConfiguration?.[name]?.displayName
          ?? "Delete object",
        type: (typeof def.parameterConfiguration?.[name]?.required === "object"
            && "listLength" in def.parameterConfiguration?.[name]?.required)
          ? {
            type: "objectReferenceList",
            objectReferenceList: { objectTypeId: def.objectType!.apiName },
          }
          : {
            type: "objectReference",
            objectReference: { objectTypeId: def.objectType!.apiName },
          },
        validation: {
          ...def.parameterConfiguration?.[name],
          allowedValues: { type: "objectQuery" },
          required: def.parameterConfiguration?.[name]?.required ?? true,
        },
        defaultValue: def.parameterConfiguration?.[name]?.defaultValue,
        description: def.parameterConfiguration?.[name]?.description,
      });
      parameterSet.delete(DELETE_OBJECT_PARAMETER);
    }
    if (name === CREATE_INTERFACE_OBJECT_PARAMETER && "interfaceType" in def) {
      targetParams.push({
        id: CREATE_INTERFACE_OBJECT_PARAMETER,
        displayName: def.parameterConfiguration?.[name]?.displayName
          ?? "Object type to create",
        type: (typeof def.parameterConfiguration?.[name]?.required === "object"
            && "listLength" in def.parameterConfiguration?.[name]?.required)
          ? {
            type: "objectReferenceList",
            objectReferenceList: { objectTypeId: def.objectType!.apiName },
          }
          : {
            type: "objectTypeReference",
            objectTypeReference: {
              interfaceTypeRids: [def.interfaceType.apiName],
            },
          },
        validation: {
          ...def.parameterConfiguration?.[name],
          required: true,
          allowedValues: def.objectType === undefined
            ? {
              type: "objectTypeReference",
              interfaceTypes: [def.interfaceType.apiName],
            }
            : {
              type: "oneOf",
              oneOf: [{
                label: def.objectType.displayName,
                value: {
                  type: "objectType",
                  objectType: { objectTypeId: def.objectType.apiName },
                },
              }],
            },
        },
        defaultValue: def.parameterConfiguration?.[name]?.defaultValue,
        description: def.parameterConfiguration?.[name]?.description,
      });
      parameterSet.delete(CREATE_INTERFACE_OBJECT_PARAMETER);
    }
    if (name === MODIFY_INTERFACE_OBJECT_PARAMETER && "interfaceType" in def) {
      targetParams.push({
        id: MODIFY_INTERFACE_OBJECT_PARAMETER,
        displayName: def.parameterConfiguration?.[name]?.displayName
          ?? "Object type to modify",
        type: (typeof def.parameterConfiguration?.[name]?.required === "object"
            && "listLength" in def.parameterConfiguration?.[name]?.required)
          ? {
            type: "interfaceReferenceList",
            interfaceReferenceList: {
              interfaceTypeRid: def.interfaceType.apiName,
            },
          }
          : {
            type: "interfaceReference",
            interfaceReference: {
              interfaceTypeRid: def.interfaceType.apiName,
            },
          },
        validation: {
          ...def.parameterConfiguration?.[name],
          required: true,
          allowedValues: def.objectType === undefined
            ? { type: "interfaceObjectQuery" }
            : {
              type: "oneOf",
              oneOf: [{
                label: def.objectType.displayName,
                value: {
                  type: "objectType",
                  objectType: { objectTypeId: def.objectType.apiName },
                },
              }],
            },
        },
        defaultValue: def.parameterConfiguration?.[name]?.defaultValue,
        description: def.parameterConfiguration?.[name]?.description,
      });
      parameterSet.delete(MODIFY_INTERFACE_OBJECT_PARAMETER);
    }
    if (name === DELETE_OBJECT_PARAMETER && "interfaceType" in def) {
      targetParams.push({
        id: DELETE_OBJECT_PARAMETER,
        displayName: def.parameterConfiguration?.[name]?.displayName
          ?? "Delete Object",
        type: (typeof def.parameterConfiguration?.[name]?.required === "object"
            && "listLength" in def.parameterConfiguration?.[name]?.required)
          ? {
            type: "interfaceReferenceList",
            interfaceReferenceList: {
              interfaceTypeRid: def.interfaceType.apiName,
            },
          }
          : {
            type: "interfaceReference",
            interfaceReference: {
              interfaceTypeRid: def.interfaceType.apiName,
            },
          },
        validation: {
          ...def.parameterConfiguration?.[name],
          required: true,
          allowedValues: def.objectType === undefined
            ? { type: "interfaceObjectQuery" }
            : {
              type: "oneOf",
              oneOf: [{
                label: def.objectType.displayName,
                value: {
                  type: "objectType",
                  objectType: { objectTypeId: def.objectType.apiName },
                },
              }],
            },
        },
        defaultValue: def.parameterConfiguration?.[name]?.defaultValue,
        description: def.parameterConfiguration?.[name]?.description,
      });
      parameterSet.delete(DELETE_OBJECT_PARAMETER);
    }
  });
  return targetParams;
}

function referencedParameterIds(
  actionDef: ActionTypeDefinition,
): Set<ParameterId> {
  const parameterIds: Set<ParameterId> = new Set();

  // section definitions
  Object.values(actionDef.sections ?? {})
    .flatMap(p => p.parameters).forEach(pId => parameterIds.add(pId));

  // form content ordering
  (actionDef.formContentOrdering ?? []).forEach(item => {
    if (item.type === "parameterId") {
      parameterIds.add(item.parameterId);
    }
  });

  // logic rules
  actionDef.rules.forEach(rule => {
    // when visiting each rule, we also do drive-by namespace prefixing
    switch (rule.type) {
      case "addInterfaceRule":
        rule.addInterfaceRule.interfaceApiName = sanitize(
          rule.addInterfaceRule.interfaceApiName,
        );
        parameterIds.add(rule.addInterfaceRule.objectTypeParameter);
        Object.entries(rule.addInterfaceRule.sharedPropertyValues).forEach(
          ([k, v]) => {
            if (v.type === "parameterId") {
              parameterIds.add(v.parameterId);
            }
            delete rule.addInterfaceRule.sharedPropertyValues[k];
            rule.addInterfaceRule.sharedPropertyValues[sanitize(k)] = v;
          },
        );
        break;
      case "modifyInterfaceRule":
        parameterIds.add(
          rule.modifyInterfaceRule.interfaceObjectToModifyParameter,
        );
        Object.entries(rule.modifyInterfaceRule.sharedPropertyValues).forEach(
          ([k, v]) => {
            if (v.type === "parameterId") {
              parameterIds.add(v.parameterId);
            }
            delete rule.modifyInterfaceRule.sharedPropertyValues[k];
            rule.modifyInterfaceRule.sharedPropertyValues[sanitize(k)] = v;
          },
        );
        break;
      case "addObjectRule":
        Object.entries(rule.addObjectRule.propertyValues).forEach(([k, v]) => {
          if (v.type === "parameterId") {
            parameterIds.add(v.parameterId);
          }
        });
        break;
      case "modifyObjectRule":
        Object.entries(rule.modifyObjectRule.propertyValues).forEach(
          ([k, v]) => {
            if (v.type === "parameterId") {
              parameterIds.add(v.parameterId);
            }
          },
        );
        break;
      case "addOrModifyObjectRuleV2":
        Object.entries(rule.addOrModifyObjectRuleV2.propertyValues).forEach(
          ([k, v]) => {
            if (v.type === "parameterId") {
              parameterIds.add(v.parameterId);
            }
          },
        );
        break;
    }
  });
  return parameterIds;
}

function extractAllowedValuesFromActionParameterType(
  type: ActionParameterType,
): ActionParameterAllowedValues {
  if (typeof type === "object") {
    switch (type.type) {
      case "objectReference":
      case "objectReferenceList":
        return { type: "objectQuery" };
      case "struct":
      case "structList":
        throw new Error("Structs are not supported yet");
      default:
        throw new Error(
          `Inferred allowed values for ${type.type} not yet supported. Please explicitly provide allowed values.`,
        );
    }
  }
  switch (type) {
    case "boolean":
    case "booleanList":
      return { type: "boolean" };
    case "integer":
    case "integerList":
    case "decimal":
    case "decimalList":
    case "double":
    case "doubleList":
    case "long":
    case "longList":
      return { type: "range" };
    case "timestamp":
    case "timestampList":
    case "date":
    case "dateList":
      return { type: "datetime" };
    case "string":
    case "stringList":
      return { type: "text" };
    case "geohash":
    case "geohashList":
      return { type: "geohash" };
    case "geoshape":
    case "geoshapeList":
      return { type: "geoshape" };
    case "mediaReference":
    case "mediaReferenceList":
      return { type: "mediaReference" };
    case "geotimeSeriesReference":
    case "geotimeSeriesReferenceList":
      return { type: "geotimeSeriesReference" };
    case "attachment":
    case "attachmentList":
      return { type: "attachment" };
    default:
      throw new Error(
        `Inferred allowed values for ${type} not yet supported. Please explicitly provide allowed values.`,
      );
  }
}

function extractAllowedValuesFromPropertyType(
  type: PropertyTypeType,
): ActionParameterAllowedValues {
  switch (type) {
    case "boolean":
      return { type: "boolean" };
    case "byte":
      return {
        type: "range",
        min: {
          type: "staticValue",
          staticValue: { type: "integer", integer: 0 },
        },
        max: {
          type: "staticValue",
          staticValue: { type: "integer", integer: 255 },
        },
      };
    case "timestamp":
    case "date":
      return { type: "datetime" };
    case "decimal":
    case "double":
    case "float":
    case "integer":
    case "long":
      return { type: "range" };
    case "short":
      return {
        type: "range",
        min: {
          type: "staticValue",
          staticValue: { type: "integer", integer: 0 },
        },
        max: {
          type: "staticValue",
          staticValue: { type: "integer", integer: 65535 },
        },
      };
    case "string":
      return { type: "text" };
    case "geopoint":
      return { type: "geohash" };
    case "geoshape":
      return { type: "geoshape" };
    case "mediaReference":
      return { type: "mediaReference" };
    case "geotimeSeries":
      return { type: "geotimeSeriesReference" };
    case "attachment":
      return { type: "attachment" };
    default:
      switch (type.type) {
        case "marking":
          return type.markingType === "CBAC"
            ? { type: "cbacMarking" }
            : { type: "mandatoryMarking" };
        case "string":
          return { type: "text" };
        case "struct":
          throw new Error("Structs are not supported yet");
        default:
          throw new Error("Unknown type");
      }
      break;
  }
}

function extractActionParameterType(
  pt:
    | InterfaceDefinedProperty
    | ObjectPropertyType
    | ObjectPropertyTypeUserDefinition,
): ActionParameterType {
  const typeType = pt.type;
  if (typeof typeType === "object") {
    switch (typeType.type) {
      case "marking":
        return maybeAddList("marking", pt);
      case "string":
        return maybeAddList("string", pt);
      case "struct":
        throw new Error("Structs are not supported yet");
      default:
        throw new Error(`Unknown type`);
    }
  }
  if (
    typeof typeType === "string" && isActionParameterTypePrimitive(typeType)
  ) {
    return maybeAddList(typeType, pt);
  }
  switch (typeType) {
    case "byte":
    case "short":
      return maybeAddList("integer", pt);
    case "geopoint":
      return maybeAddList("geohash", pt);
    case "float":
      return maybeAddList("double", pt);
    case "geotimeSeries":
      return maybeAddList("geotimeSeriesReference", pt);
    default:
      throw new Error("Unknown type");
  }
}

function maybeAddList(
  type: ActionParameterTypePrimitive,
  pt:
    | InterfaceDefinedProperty
    | ObjectPropertyType
    | ObjectPropertyTypeUserDefinition,
): ActionParameterType {
  return ((pt.array ?? false) ? type + "List" : type) as ActionParameterType;
}

export function kebab(s: string): string {
  return s
    .replace(/([a-z])([A-Z])/g, "$1-$2")
    .replace(/([A-Z])([A-Z][a-z])/g, "$1-$2")
    .replace(/\./g, "-")
    .toLowerCase();
}

function sanitize(s: string): string {
  return s.includes(".") ? s : namespace + s;
}

export function convertValidationRule(
  actionValidation: ActionLevelValidationDefinition,
  actionParameters?: ActionParameter[],
): Array<ActionValidationRule> {
  return actionValidation.map(rule => {
    return {
      condition: convertConditionDefinition(rule.condition, actionParameters),
      displayMetadata: rule.displayMetadata ?? {
        failureMessage: "Did not satisfy validation",
        typeClasses: [],
      },
    };
  });
}

function validateActionConfiguration(action: ActionType): void {
  const seenParameterIds = new Set<ParameterId>();
  const parameterMap: Record<string, ActionParameter> =
    action.parameters?.reduce((acc, param) => {
      acc[param.id] = param;
      return acc;
    }, {} as Record<string, ActionParameter>) ?? {};
  const orderedParameters =
    action.parameterOrdering?.map(id => parameterMap[id]) ?? action.parameters;
  orderedParameters?.forEach(param => {
    param.validation.conditionalOverrides?.forEach(override => {
      validateParameterCondition(
        override.condition,
        param.id,
        seenParameterIds,
        action.parameters,
      );
    });
    validateParameterPrefill(
      param.id,
      seenParameterIds,
      action.parameters,
      param.defaultValue,
    );
    seenParameterIds.add(param.id);
  });
}

function validateParameterCondition(
  condition: ConditionDefinition,
  currentParameterId: ParameterId,
  seenParameterIds: Set<ParameterId>,
  parameters?: ActionParameter[],
): void {
  switch (condition.type) {
    case "parameter":
      const overrideParamId = condition.parameterId;
      invariant(
        parameters?.some(p => p.id === overrideParamId),
        `Parameter condition on ${currentParameterId} is referencing unknown parameter ${overrideParamId}`,
      );
      invariant(
        overrideParamId !== currentParameterId,
        `Parameter condition on ${currentParameterId} is referencing itself`,
      );
      invariant(
        seenParameterIds.has(overrideParamId),
        `Parameter condition on ${currentParameterId} is referencing later parameter ${overrideParamId}`,
      );
      break;
    case "and":
      // this will not catch the niche edge case where users use the full syntax for unions
      if ("conditions" in condition) {
        condition.conditions.forEach(c =>
          validateParameterCondition(
            c,
            currentParameterId,
            seenParameterIds,
            parameters,
          )
        );
      }
      break;
    case "or":
      if ("conditions" in condition) {
        condition.conditions.forEach(c =>
          validateParameterCondition(
            c,
            currentParameterId,
            seenParameterIds,
            parameters,
          )
        );
      }
      break;
    case "comparison":
    case "group":
    case "not":
    case "markings":
    case "regex":
    case "redacted":
    case "true":
      break;
    default:
      throw new Error(
        `Unknown condition type on parameter ${currentParameterId}`,
      );
  }
}

function validateParameterPrefill(
  currentParameterId: ParameterId,
  seenParameterIds: Set<ParameterId>,
  parameters?: ActionParameter[],
  defaultValue?: OntologyIrParameterPrefill,
): void {
  if (!defaultValue) return;
  switch (defaultValue.type) {
    case "objectParameterPropertyValue":
      invariant(
        parameters?.some(p =>
          p.id === defaultValue.objectParameterPropertyValue.parameterId
        ),
        `Default value for parameter ${currentParameterId} is referencing unknown parameter ${defaultValue.objectParameterPropertyValue.parameterId}`,
      );
      invariant(
        seenParameterIds.has(
          defaultValue.objectParameterPropertyValue.parameterId,
        ),
        `Default value for parameter ${currentParameterId} is referencing later parameter ${defaultValue.objectParameterPropertyValue.parameterId}`,
      );
      break;
    case "staticValue":
      invariant(
        defaultValue.staticValue.type
          === parameters?.find(p => p.id === currentParameterId)?.type,
        `Default static value for parameter ${currentParameterId} does not match type`,
      );
      break;
    case "staticObject":
    case "interfaceParameterPropertyValue":
    case "objectQueryPrefill":
    case "objectQueryPropertyValue":
    case "objectSetRidPrefill":
    case "redacted":
      break;
    default:
      throw new Error(
        `Unknown default value type for parameter ${currentParameterId}`,
      );
  }
}

export function validateActionParameters(
  def: ActionTypeUserDefinition | InterfaceActionTypeUserDefinition,
  properties: Array<string>,
  name: string,
): void {
  // validates that parameters either exist as object properties or have a type defined
  [
    ...Object.keys(def.parameterConfiguration ?? {}),
  ].forEach(id => {
    invariant(
      properties.includes(id)
        || properties.includes(addNamespaceIfNone(id))
        || (def.parameterConfiguration?.[id].customParameterType !== undefined)
        || isTargetParameter(id),
      `Parameter ${id} does not exist as a property on ${name} and its type is not explicitly defined`,
    );
  });
  [
    ...Object.keys(def.nonParameterMappings ?? {}),
    ...def.excludedProperties ?? [],
  ].forEach(id => {
    invariant(
      properties.includes(id)
        || properties.includes(addNamespaceIfNone(id))
        || properties.includes(withoutNamespace(id)),
      `Property ${id} does not exist as a property on ${name}`,
    );
  });
}

// Parameters with configurations will be ordered first in the order they were defined
// followed by the rest of the parameters in the order they were defined on the object type.
export function createDefaultParameterOrdering(
  def: ActionTypeUserDefinition | InterfaceActionTypeUserDefinition,
  properties: Array<string>,
  parameters: ActionParameter[],
  priorityId?: string,
): string[] {
  return [
    ...priorityId ? [priorityId] : [],
    ...Object.keys(def.parameterConfiguration ?? {}).filter(id =>
      id !== priorityId
    ),
    ...properties.filter(id =>
      !def.parameterConfiguration?.[id] && parameters.some(p => p.id === id)
    ),
  ];
}

export function validateParameterOrdering(
  parameterOrdering: string[],
  parameterSet: Set<string>,
  actionApiName: string,
): void {
  const orderingSet = new Set(parameterOrdering);
  const missingParameters = [...parameterSet].filter(
    param => !orderingSet.has(param),
  );
  const extraneousParameters = parameterOrdering.filter(param =>
    !parameterSet.has(param)
  );
  invariant(
    extraneousParameters.length === 0
      && missingParameters.length === 0,
    `Action parameter ordering for ${actionApiName} does not match expected parameters. Extraneous parameters in ordering: {${extraneousParameters}}, Missing parameters in ordering: {${missingParameters}}`,
  );
}

export function isTargetParameter(parameterId: string): boolean {
  return parameterId === MODIFY_OBJECT_PARAMETER
    || parameterId === CREATE_OR_MODIFY_OBJECT_PARAMETER
    || parameterId === CREATE_INTERFACE_OBJECT_PARAMETER
    || parameterId === MODIFY_INTERFACE_OBJECT_PARAMETER;
}

export function addNamespaceToActionDefinition(
  def: InterfaceActionTypeUserDefinition,
): void {
  def.parameterConfiguration = Object.fromEntries(
    Object.entries(def.parameterConfiguration ?? {})
      .map((
        [id, config],
      ) => [getInterfaceParameterName(def, id), config]),
  );
  def.nonParameterMappings = Object.fromEntries(
    Object.entries(def.nonParameterMappings ?? {})
      .map(([id, value]) => [addNamespaceIfNone(id), value]),
  );
  def.excludedProperties = (def.excludedProperties
    ?? []).map(id => addNamespaceIfNone(id));
  def.sections = def.sections?.map(section => ({
    ...section,
    parameters: section.parameters.map(p => getInterfaceParameterName(def, p)),
  }));
}

// Adds a namespace to an interface parameter name if it is supposed to be namespaced
export function getInterfaceParameterName(
  def: InterfaceActionTypeUserDefinition,
  parameter: string,
): string {
  if (def.useNonNamespacedParameters) {
    return getNonNamespacedParameterName(def, parameter);
  }
  return (isTargetParameter(parameter)
      || !Object.keys(def.interfaceType.propertiesV2).includes(
        addNamespaceIfNone(parameter),
      ))
    ? parameter
    : addNamespaceIfNone(parameter);
}

export function getNonNamespacedParameterName(
  def: InterfaceActionTypeUserDefinition,
  parameter: string,
): string {
  return def.conflictingParameterOverrides?.[parameter]
    ?? (parameter.split(".").pop() || parameter);
}

export function createInterfacePropertyLogicRuleValue(
  id: string,
  def: InterfacePropertyType,
  actionDef: InterfaceActionTypeUserDefinition,
): OntologyIrInterfacePropertyLogicRuleValue {
  const type = getInterfacePropertyTypeType(def);
  const array = isInterfaceSharedPropertyType(def)
    ? def.sharedPropertyType.array
    : def.array;
  const parameterId = actionDef.useNonNamespacedParameters
    ? getNonNamespacedParameterName(actionDef, id)
    : id;
  if (isStruct(type)) {
    return {
      type: "structLogicRuleValue",
      structLogicRuleValue: Object.fromEntries(
        Object.entries(type.structDefinition).map(([apiName, fieldValue]) => {
          return [
            apiName,
            array
              ? {
                type: "structListParameterFieldValue",
                structListParameterFieldValue: {
                  parameterId: parameterId,
                  structFieldApiName: apiName,
                },
              }
              : {
                type: "structParameterFieldValue",
                structParameterFieldValue: {
                  parameterId: parameterId,
                  structFieldApiName: apiName,
                },
              },
          ];
        }),
      ),
    };
  }
  return {
    type: "logicRuleValue",
    logicRuleValue: {
      type: "parameterId",
      parameterId: parameterId,
    },
  };
}
