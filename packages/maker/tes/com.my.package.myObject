{"loadSingleObjectGuide":"import { com.my.package.myObject } from \"testing.name\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\nimport { isOk, type Osdk, type Result } from \"@osdk/client\";\n\nconst result: Result<Osdk.Instance<com.my.package.myObject>> = await client(com.my.package.myObject).fetchOneWithErrors(\"<primaryKey>\");\nif (isOk(result)) {\n    const object: Osdk.Instance<com.my.package.myObject> = result.value;\n} else {\n    console.error(result.error.message);\n}\n// You can also fetch a single object without the Result wrapper\ntry {\n    const object: Osdk.Instance<com.my.package.myObject> = await client(com.my.package.myObject).fetchOne(\"<primaryKey>\");\n}\ncatch(e) {\n    console.error(e);\n}","loadObjectsReference":"import { com.my.package.myObject } from \"testing.name\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\nimport type { Osdk, PageResult, Result } from \"@osdk/client\";\n\nconst response:  Result<PageResult<Osdk.Instance<com.my.package.myObject>>>\n    = await client(com.my.package.myObject).fetchPageWithErrors({ $pageSize: 30 });\n\n// To fetch a page without a result wrapper, use fetchPage instead\nconst responseNoErrorWrapper: PageResult<Osdk.Instance<com.my.package.myObject>>\n    = await client(com.my.package.myObject).fetchPage({ $pageSize: 30 });\n","loadAllObjectsReference":"import { com.my.package.myObject } from \"testing.name\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\nimport type { Osdk } from \"@osdk/client\";\n\nconst objects: Osdk.Instance<com.my.package.myObject>[]= [];\n\nfor await(const obj of client(com.my.package.myObject).asyncIter()) {\n    objects.push(obj);\n}\nconst object = objects[0];","loadOrderedInterfacesReference":"import {  } from \"testing.name\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\nimport { isOk, type Osdk, type PageResult, type Result } from \"@osdk/client\";\n\nconst page: Result<PageResult<Osdk<>>> = await client()\n    .fetchPageWithErrors({\n        $orderBy: {\"someProperty\": \"asc\"},\n        $pageSize: 30\n    });\n\nif (isOk(page)) {\n    const interfaces = page.value.data;\n    const interface1 = interfaces[0];\n}","searchObjectsGuide":"import { com.my.package.myObject } from \"testing.name\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\nimport { isOk, type Osdk, type PageResult, type Result } from \"@osdk/client\";\n\nconst page: Result<PageResult<Osdk.Instance<com.my.package.myObject>>> = await client(com.my.package.myObject)\n    .where({\n        : {$isNull: true}\n    })\n    .fetchPageWithErrors({\n        $pageSize: 30\n    });\n\nif (isOk(page)) {\n    const objects = page.value.data;\n    const object = objects[0];\n}","aggregationTemplate":"import { com.my.package.myObject } from \"testing.name\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\n\nconst numcom.my.package.myObject = await client(com.my.package.myObject)\n    .where(: { $isNull : false })\n    .aggregate({\n        $select: { $count: \"unordered\" },\n        $groupBy: { name: \"exact\" },\n    });","objectSetOperationsGuide":"import { com.my.package.myObject } from \"testing.name/ontology/objects\";\n\nconst objectSetA = client(com.my.package.myObject).where({ : { $containsAnyTerm: \"a\"}})\nconst objectSetB = client(com.my.package.myObject).where({ : { $containsAnyTerm: \"b\"}})\nconst objectSetC = client(com.my.package.myObject).where({ : { $containsAnyTerm: \"c\"}})\n\n// Object set operations can be chained. e.g. To find all objects in objectSetA \n// that are present in objectSetB but do not exist in objectSetC:\nconst result = objectSetA\n  .intersect(objectSetB)\n  .subtract(objectSetC);","loadObjectMetadataSnippet":"import { com.my.package.myObject } from \"testing.name\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\n\nconst objectTypeMetadata = await client.fetchMetadata(com.my.package.myObject);\n\nif (objectTypeMetadata.icon.type === \"blueprint\") {\n    const blueprintIconName = objectTypeMetadata.icon.name;\n}\nconst currentVisibility = objectTypeMetadata.visibility;\nconst currentDescription = objectTypeMetadata.description;","subscribeToObjectSetInstructions":"import { com.my.package.myObject } from \"testing.name\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\n\n// A map of primary keys to objects loaded through the SDK\nconst objects: { [key: string]: com.my.package.myObject.OsdkInstance } = ...\n\nconst subscription = client(com.my.package.myObject).subscribe(         {\n            onChange(update) {\n                if (update.state === \"ADDED_OR_UPDATED\") {\n                    // An object has received an update or an object was added to the object set\n                    const currentObject = objects[update.object.$primaryKey];\n                    if (currentObject !== undefined) {\n                        currentObject[\"<propertyName>\"] = update.object[\"<propertyName>\"] ?? currentObject[\"<propertyName>\"];\n                    }\n                }\n                else if (update.state === \"REMOVED\") {\n                    // The object was removed from the object set, which could mean it was deleted or no longer meets the filter criteria\n                    delete objects[update.object.$primaryKey];\n                }\n            },\n            onSuccessfulSubscription() {\n                // The subscription was successful and you can expect to receive updates\n            },\n            onError(err) {\n                // There was an error with the subscription and you will not receive any more updates\n                console.error(err);\n            },\n            onOutOfDate() {\n                // We could not keep track of all changes. Please reload the objects in your set.\n            },\n        },\n        { properties: [ \b\b]}\n    );\n\nsubscription.unsubscribe();"}