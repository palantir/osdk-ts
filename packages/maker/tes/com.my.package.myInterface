{"loadInterfacesReference":"import { com.my.package.myInterface } from \"testing.name\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\nimport { type Osdk, type PageResult, type Result } from \"@osdk/client\";\n\nconst response:  Result<PageResult<Osdk<com.my.package.myInterface>>>\n    = await client(com.my.package.myInterface).fetchPageWithErrors({ $pageSize: 30 });\n\n// To fetch a page without a result wrapper, use fetchPage instead\nconst responseNoErrorWrapper: PageResult<Osdk<com.my.package.myInterface>>\n    = await client(com.my.package.myInterface).fetchPage({ $pageSize: 30 });","loadAllInterfacesReference":"import { com.my.package.myInterface } from \"testing.name\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\nimport type { Osdk } from \"@osdk/client\";\n\nconst interfaces: Osdk<com.my.package.myInterface>[] = [];\n\nfor await(const int of client(com.my.package.myInterface).asyncIter()) {\n    interfaces.push(int);\n}\nconst interface1 = interfaces[0];","loadOrderedInterfacesReference":"import { com.my.package.myInterface } from \"testing.name\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\nimport { isOk, type Osdk, type PageResult, type Result } from \"@osdk/client\";\n\nconst page: Result<PageResult<Osdk<com.my.package.myInterface>>> = await client(com.my.package.myInterface)\n    .fetchPageWithErrors({\n        $orderBy: {\"someProperty\": \"asc\"},\n        $pageSize: 30\n    });\n\nif (isOk(page)) {\n    const interfaces = page.value.data;\n    const interface1 = interfaces[0];\n}","searchInterfacesReference":"import { com.my.package.myInterface } from \"testing.name\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\nimport { isOk, type Osdk, type PageResult, type Result } from \"@osdk/client\";\n\nconst page: Result<PageResult<Osdk<com.my.package.myInterface>>> = await client(com.my.package.myInterface)\n    .where({\n        $and:[\n            { $not: { someProperty: { $isNull: true }}},\n            { someProperty: { $eq: \"foo\" }}\n        ]\n    })\n    .fetchPageWithErrors({\n        $pageSize: 30\n    });\n\nif (isOk(page)) {\n    const interfaces = page.value.data;\n    const interface1 = interfaces[0];\n}","loadInterfaceMetadataSnippet":"import { com.my.package.myInterface } from \"testing.name\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\n\nconst interfaceTypeMetadata = await client.fetchMetadata(com.my.package.myInterface);\n\nconst implementingObjectTypes = interfaceTypeMetadata.implementedBy;\nconst interfaceRid = interfaceTypeMetadata.rid;","subscribeToObjectSetInstructions":"import { com.my.package.myInterface } from \"testing.name\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\n\n// A map of primary keys to objects loaded through the SDK\nconst objects: { [key: string]: com.my.package.myInterface.OsdkInstance } = ...\n\nconst subscription = client(com.my.package.myInterface).subscribe(         {\n            onChange(update) {\n                if (update.state === \"ADDED_OR_UPDATED\") {\n                    // An object has received an update or an object was added to the object set\n                    const currentObject = objects[update.object.$primaryKey];\n                    if (currentObject !== undefined) {\n                        currentObject[\"<propertyName>\"] = update.object[\"<propertyName>\"] ?? currentObject[\"<propertyName>\"];\n                    }\n                }\n                else if (update.state === \"REMOVED\") {\n                    // The object was removed from the object set, which could mean it was deleted or no longer meets the filter criteria\n                    delete objects[update.object.$primaryKey];\n                }\n            },\n            onSuccessfulSubscription() {\n                // The subscription was successful and you can expect to receive updates\n            },\n            onError(err) {\n                // There was an error with the subscription and you will not receive any more updates\n                console.error(err);\n            },\n            onOutOfDate() {\n                // We could not keep track of all changes. Please reload the objects in your set.\n            },\n        },\n        { properties: [ \"com.my.package.mySpt\", \b\b]}\n    );\n\nsubscription.unsubscribe();"}