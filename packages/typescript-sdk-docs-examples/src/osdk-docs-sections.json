{
  "sections": [
    {
      "title": "Loading data",
      "description": "Methods for loading and retrieving data from the OSDK API",
      "subsections": [
        {
          "title": "Load single Employee",
          "description": "Load a single Employee object using its primary key.",
          "parameters": {
            "primaryKey": {
              "type": "need to match the primary key type",
              "description": "The primary key of the Employee you want to fetch"
            }
          },
          "code_snippets": {
            "typescript": {
              "2.0.0": [
                {
                  "title": "Loading a single Employee by ID",
                  "code": "import { Employee } from \"../../../generatedNoCheck\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\nimport { isOk, type Osdk, type Result } from \"@osdk/client\";\n\nconst result: Result<Osdk.Instance<Employee>> = await client(Employee).fetchOneWithErrors(\"<primaryKey>\");\nif (isOk(result)) {\n    const object: Osdk.Instance<Employee> = result.value;\n} else {\n    console.error(result.error.message);\n}\n// You can also fetch a single object without the Result wrapper\ntry {\n    const object: Osdk.Instance<Employee> = await client(Employee).fetchOne(\"<primaryKey>\");\n}\ncatch(e) {\n    console.error(e);\n}"
                }
              ]
            }
          }
        },
        {
          "title": "Load pages of Employees",
          "description": "Load a list of objects of a requested page size, after a given page token if present.",
          "note": "Note that this endpoint leverages the underlying object syncing technology used for the object type. If Employee is backed by Object Storage V2, there is no request limit. If it is backed by Phonograph, there is a limit of 10,000 results â€“ when more than 10,000 Employees have been requested, a ObjectsExceededLimit error will be thrown. To load all objects, you should iterate through pages until pageToken returns null, indicating there are no more objects to retrieve.",
          "parameters": {
            "pageSize": {
              "type": "integer",
              "optional": true,
              "description": "The size of the page to request up to a maximum of 10,000. If not provided, will load up to 10,000 Employees."
            },
            "pageToken": {
              "type": "string",
              "optional": true,
              "description": "If provided, will request a page with size less than or equal to the pageSize of the first requested page."
            },
            "$orderBy": {
              "type": "object",
              "optional": true,
              "description": "Specify properties and sort directions to order the results. The sort order for strings is case-sensitive, meaning numbers will come before uppercase letters, which will come before lowercase letters. For example, \"Cat\" will come before \"bat\"."
            }
          },
          "code_snippets": {
            "typescript": {
              "2.0.0": [
                {
                  "title": "Loading pages of employees",
                  "code": "import { Employee } from \"../../../generatedNoCheck\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\nimport { isOk, type Osdk, type PageResult, type Result } from \"@osdk/client\";\n\nconst firstPage: Result<PageResult<Osdk.Instance<Employee>>>\n    = await client(Employee).fetchPageWithErrors({ $pageSize: 30 });\n\nif (isOk(firstPage)) {\n    const secondPage: Result<PageResult<Osdk.Instance<Employee, never, \"fullName\">>>\n    // You can also down select properties to only get the properties you need from the object\n    = await client(Employee).fetchPageWithErrors({ $select: [\"fullName\"], $pageSize: 30, $nextPageToken: firstPage.value.nextPageToken });\n\n    const objects = isOk(secondPage) ? [...firstPage.value.data, ...secondPage.value.data] : firstPage.value.data;\n    const object = objects[0];\n}\n\n // If you want to get rids, you need to add a flag to specifically request for it. Note how the return type now includes $rid rather than never\nconst secondPageWithRids: Result<PageResult<Osdk.Instance<Employee, \"$rid\", \"fullName\">>>\n    = await client(Employee).fetchPageWithErrors({ $select: [\"fullName\"], $includeRid:true, $pageSize: 30, $nextPageToken: firstPage.value.nextPageToken });\n\n// To fetch a page without a result wrapper, use fetchPage with a try/catch instead\ntry {\n    const firstPage: PageResult<Osdk.Instance<Employee>>\n        = await client(Employee).fetchPage({ $pageSize: 30 });\n    const secondPage: PageResult<Osdk.Instance<Employee>>\n     = await client(Employee).fetchPage({ $pageSize: 30, $nextPageToken: firstPage.nextPageToken });\n    const objects = [...firstPage.data, ...secondPage.data];\n    const object = objects[0];\n}\ncatch (e) {\n    console.error(e);\n}"
                },
                {
                  "title": "Loading ordered results",
                  "code": "import { Employee } from \"../../../generatedNoCheck\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\nimport { isOk, type Osdk, type PageResult, type Result } from \"@osdk/client\";\n\nconst page: Result<PageResult<Osdk.Instance<Employee>>> = await client(Employee)\n    .fetchPageWithErrors({\n        $orderBy: {\"fullName\": \"asc\"},\n        $pageSize: 30\n    });\n\nif (isOk(page)) {\n    const objects = page.value.data;\n    const object = objects[0];\n}"
                }
              ]
            }
          }
        },
        {
          "title": "Load linked object types",
          "description": "You can load linked object types by using either the $link property on an object to load a single linked object or fetch a page of linked objects.",
          "note": "The $link property provides access to all linked objects defined in the ontology, allowing you to follow object relationships.",
          "examples": [
            "Load a single linked Office object: employee.$link.primaryOffice.fetchOne()",
            "Load a page of linked Employee objects: employee.$link.directReports.fetchPage()"
          ],
          "code_snippets": {
            "typescript": {
              "2.0.0": [
                {
                  "title": "Working with linked objects",
                  "code": "import { Employee, Equipment } from \"../../../generatedNoCheck\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\nimport { type Osdk, type Result } from \"@osdk/client\";\n\nfunction getLinkedEquipment(source: Osdk.Instance<Employee>, linkedObjectPrimaryKey: string): Result<Osdk.Instance<Equipment>>\n{\n    return source.$link.assignedEquipment.fetchOneWithErrors(linkedObjectPrimaryKey);\n}\n\n// You can also get a linked object without the result wrapper\nfunction getLinkedNoWrapperEquipment(source: Osdk.Instance<Employee>, linkedObjectPrimaryKey: string): Osdk.Instance<Equipment> {\n    return source.$link.assignedEquipment.fetchOne(linkedObjectPrimaryKey);\n}"
                }
              ]
            }
          }
        }
      ]
    },
    {
      "title": "Filtering",
      "description": "Filter Employee objects based on different criteria",
      "subsections": [
        {
          "title": "String Filters",
          "description": "Search and filter string values with various matching operators.",
          "operators": {
            "$startsWith": {
              "description": "Operator for prefix matching against a string property. For example, \"foo\" will match \"foobar\" but not \"barfoo\".",
              "applies_to": "Only applies to string properties."
            },
            "$containsAnyTerm": {
              "description": "White space separated set of words to match on. For example, \"foo bar\" will match \"bar baz\" but not \"baz qux\".",
              "applies_to": "Only applies to string properties."
            },
            "$containsAllTerms": {
              "description": "White space separated set of words to match on. For example, \"foo bar\" will match \"hello foo baz bar\" but not \"foo qux\".",
              "applies_to": "Only applies to string properties."
            },
            "$containsAllTermsInOrder": {
              "description": "White space separated set of words to match on. For example, \"foo bar\" will match \"hello foo bar baz\" but not \"bar foo qux\".",
              "applies_to": "Only applies to string properties."
            }
          },
          "code_snippets": {
            "typescript": {
              "2.0.0": [
                {
                  "title": "Filtering Employees by name prefix",
                  "code": "import { Employee } from \"../../../generatedNoCheck\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\n\nconst EmployeeObjectSet = client(Employee)\n    .where({\n        : { : { $startsWith: \"foo\" }}\n    })"
                }
              ]
            }
          }
        },
        {
          "title": "Comparison Filters",
          "description": "Compare values using different operators for filtering data.",
          "operators": {
            "$lt": {
              "description": "Less than operator to compare a property against a value.",
              "applies_to": "Applies to numeric, date, and timestamp properties."
            },
            "$lte": {
              "description": "Less than or equal to operator for comparison.",
              "applies_to": "Applies to numeric, date, and timestamp properties."
            },
            "$gt": {
              "description": "Greater than operator for comparison.",
              "applies_to": "Applies to numeric, date, and timestamp properties."
            },
            "$gte": {
              "description": "Greater than or equal to operator for comparison.",
              "applies_to": "Applies to numeric, date, and timestamp properties."
            },
            "$eq": {
              "description": "Equality operator to check a property against a value.",
              "applies_to": "Only applies to Boolean, datetime, numeric, and string properties."
            },
            "$in": {
              "description": "In operator to check if a property equals one of the values in the array.",
              "applies_to": "Only applies to Boolean, datetime, numeric, and string properties."
            },
            "$isNull": {
              "description": "Operator to check whether or not a property exists.",
              "applies_to": "Only applies to array, Boolean, datetime, numeric, and string properties."
            }
          },
          "code_snippets": {
            "typescript": {
              "2.0.0": [
                {
                  "title": "Filtering employees by salary range",
                  "code": "import { Employee } from \"../../../generatedNoCheck\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\n\nconst EmployeeObjectSet = client(Employee)\n    .where({\n        : { : { $:  }}\n    });"
                },
                {
                  "title": "Filtering employees using equality and in operators",
                  "code": "import { Employee } from \"../../../generatedNoCheck\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\n\nconst EmployeeObjectSet = client(Employee)\n    .where({\n        : { : { $eq:  }}\n    });"
                }
              ]
            }
          }
        },
        {
          "title": "Boolean Filters",
          "description": "Combine and modify search queries with logical operators.",
          "operators": {
            "$not": {
              "description": "Not operator that inverts the search query.",
              "applies_to": "Can be applied to any filter condition."
            },
            "$and": {
              "description": "And operator that combines multiple search queries.",
              "applies_to": "Returns objects where all queries are satisfied."
            },
            "$or": {
              "description": "Or operator that combines multiple search queries.",
              "applies_to": "Returns objects where any queries are satisfied."
            }
          },
          "code_snippets": {
            "typescript": {
              "2.0.0": [
                {
                  "title": "Using boolean operators for complex filtering",
                  "code": "import { Employee } from \"../../../generatedNoCheck\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\n\nconst EmployeeObjectSet = client(Employee)\n    .where({ $not: { employeeId: { $isNull: true }}});"
                }
              ]
            }
          }
        }
      ]
    },
    {
      "title": "Aggregations",
      "description": "Perform calculations and statistical analysis on sets of Employee objects.",
      "subsections": [
        {
          "title": "Types of aggregations",
          "description": "Operators for computing statistical aggregations across records.",
          "operators": {
            "count": {
              "description": "Returns the total count of records.",
              "applies_to": "Can be used on any object set."
            },
            "approximateDistinct": {
              "description": "Returns an approximated count of the distinct values of a property.",
              "applies_to": "Can be used on any property type."
            },
            "exactDistinct": {
              "description": "Returns the exact count of distinct values for a property.",
              "applies_to": "Can be used on any property type."
            },
            "avg": {
              "description": "Calculates the average value of a numeric property.",
              "applies_to": "Only applies to numeric properties."
            },
            "max": {
              "description": "Finds the maximum value of a numeric property.",
              "applies_to": "Only applies to numeric properties."
            },
            "min": {
              "description": "Finds the minimum value of a numeric property.",
              "applies_to": "Only applies to numeric properties."
            },
            "sum": {
              "description": "Calculates the sum of values for a numeric property.",
              "applies_to": "Only applies to numeric properties."
            }
          },
          "code_snippets": {
            "typescript": {
              "2.0.0": [
                {
                  "title": "Using aggregation operators",
                  "code": "import { Employee } from \"../../../generatedNoCheck\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\n\nconst numEmployee = await client(Employee)\n    .aggregate({\n        $select: {$count: \"unordered\"},\n    });"
                }
              ]
            }
          }
        },
        {
          "title": "Types of group bys",
          "description": "Operators for grouping records based on property values.",
          "operators": {
            "exact": {
              "description": "Groups records by exact values of a property.",
              "applies_to": "Can be used on any property type."
            },
            "range": {
              "description": "Groups records by specified ranges of a property.",
              "applies_to": "Only applies to numeric, date, and timestamp properties."
            }
          },
          "code_snippets": {
            "typescript": {
              "2.0.0": [
                {
                  "title": "Using group by with aggregations",
                  "code": "import { Employee } from \"../../../generatedNoCheck\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\n\nconst groupedEmployee = await client(Employee)\n    .aggregate({\n        $select: { $count: \"unordered\" },\n        $groupBy: { department : \"exact\" }\n    })"
                }
              ]
            }
          }
        }
      ]
    },
    {
      "title": "Object set operations",
      "description": "Foundry object sets represent unordered collections of objects of a single type. These sets can be manipulated and combined by chaining object set operations to return a new object set of the same type.",
      "note": "Note that Filtering can also be used to manipulate object sets.",
      "subsections": [
        {
          "title": "Set operations",
          "operations": {
            "union": {
              "description": "The union operation creates a new object set composed of objects present in any of the given object sets."
            },
            "subtract": {
              "description": "The subtract operation creates a new object set containing objects present in the first object set but not in the second object set."
            },
            "intersect": {
              "description": "The intersect operation creates a new object set containing only objects that are present in all given object sets."
            }
          },
          "code_snippets": {
            "typescript": {
              "2.0.0": [
                {
                  "title": "Combining object sets using set operations",
                  "code": "import { Employee } from \"../../../generatedNoCheck/ontology/objects\";\n\nconst objectSetA = client(Employee).where({ fullName: { $containsAnyTerm: \"a\"}})\nconst objectSetB = client(Employee).where({ fullName: { $containsAnyTerm: \"b\"}})\nconst objectSetC = client(Employee).where({ fullName: { $containsAnyTerm: \"c\"}})\n\n// Object set operations can be chained. e.g. To find all objects in objectSetA \n// that are present in objectSetB but do not exist in objectSetC:\nconst result = objectSetA\n  .intersect(objectSetB)\n  .subtract(objectSetC);"
                }
              ]
            }
          }
        }
      ]
    },
    {
      "title": "Derived Properties",
      "description": "Derived properties are properties that are calculated at runtime based on the values of other properties or links on Employee objects. This includes aggregating on or selecting properties of linked objects.",
      "note": "These properties have definitions that are defined in code, then used in future object set operations, such as filtering, sorting, or aggregating.",
      "subsections": [
        {
          "title": "Types of link aggregations",
          "description": "Operators for aggregating values through object links.",
          "operators": {
            "exactDistinct": {
              "description": "Returns the exact number of distinct values for a property accessed through a link."
            },
            "$count": {
              "description": "Returns the count of linked objects."
            },
            "approximateDistinct": {
              "description": "Returns the approximate number of distinct values for a property accessed through a link."
            },
            "collectList": {
              "description": "Returns a list of values for a property accessed through a link."
            },
            "collectSet": {
              "description": "Returns a set of unique values for a property accessed through a link."
            }
          },
          "code_snippets": {
            "typescript": {
              "2.0.0": [
                {
                  "title": "Creating and using derived properties",
                  "code": "import { Employee } from \"../../../generatedNoCheck\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\n\nconst sumEmployee = await client(Employee)\n    .withProperties({\n      \"newPropertyName\": (baseObjectSet) =>\n        baseObjectSet.pivotTo(\"fooLink\").pivotTo(\"barLink\").selectProperty(\"foo\")\n    })\n    .where({\n      \"newPropertyName\": { $gt: 10 }\n    })\n    .aggregate({\n      $select: { \"newPropertyName:max\": \"unordered\" }\n    });"
                }
              ]
            }
          }
        }
      ]
    },
    {
      "title": "Load Employee metadata",
      "description": "Load up-to-date metadata for the Employee object type, such as the display name, icon, visibility, and status.",
      "note": "Note that this will return the latest information regardless of the version of your generated SDK. This means you may receive new properties, interfaces, or other metadata that your SDK itself is not yet aware of. If you wish to include these in your SDK, regenerate your SDK.",
      "code_snippets": {
        "typescript": {
          "2.0.0": [
            {
              "title": "Loading object type metadata",
              "code": "import { Employee } from \"../../../generatedNoCheck\";\n// Edit this import if your client location differs\nimport { client } from \"./client\";\n\nconst objectTypeMetadata = await client.fetchMetadata(Employee);\n\nif (objectTypeMetadata.icon.type === \"blueprint\") {\n    const blueprintIconName = objectTypeMetadata.icon.name;\n}\nconst currentVisibility = objectTypeMetadata.visibility;\nconst currentDescription = objectTypeMetadata.description;"
            }
          ]
        }
      }
    }
  ]
}